-- === Reference / Enum-like tables ===
CREATE TABLE customer_statuses (
  status_id   INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  status_name VARCHAR(50) UNIQUE NOT NULL
);

CREATE TABLE invoice_statuses (
  status_id   INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  status_name VARCHAR(50) UNIQUE NOT NULL
);

CREATE TABLE cheque_statuses (
  status_id   INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  status_name VARCHAR(50) UNIQUE NOT NULL
);

-- === Geography / routing ===
CREATE TABLE areas (
  area_id     INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  area_name   VARCHAR(255) NOT NULL,
  description TEXT
);

CREATE TABLE routes (
  route_id    INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  route_name  VARCHAR(255) NOT NULL,
  area_id     INT NOT NULL REFERENCES areas(area_id) ON DELETE RESTRICT,
  description TEXT,
  CONSTRAINT uq_routes_area UNIQUE (route_name, area_id)
);

-- === Core entities ===
CREATE TABLE customers (
  customer_id      INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  customer_name    VARCHAR(255) NOT NULL,
  contact_person   VARCHAR(255),
  phone_number     VARCHAR(50),
  email            VARCHAR(255) UNIQUE,
  address          TEXT,
  description      TEXT,
  area_id          INT NOT NULL REFERENCES areas(area_id) ON DELETE RESTRICT,
  status_id        INT NOT NULL REFERENCES customer_statuses(status_id) ON DELETE RESTRICT,
  reliability_score INT NOT NULL DEFAULT 100 CHECK (reliability_score BETWEEN 0 AND 100),
  route_id         INT REFERENCES routes(route_id) ON DELETE SET NULL,
  created_at       TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_customers_status ON customers(status_id);
CREATE INDEX idx_customers_area ON customers(area_id);
CREATE INDEX idx_customers_route ON customers(route_id);

CREATE TABLE invoices (
  invoice_id      INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  invoice_number  VARCHAR(50) NOT NULL UNIQUE,
  customer_id     INT NOT NULL REFERENCES customers(customer_id) ON DELETE RESTRICT,
  invoice_date    DATE NOT NULL,
  due_date        DATE NOT NULL,
  currency_code   CHAR(3) NOT NULL DEFAULT 'LKR',
  fx_rate         NUMERIC(12,6) NOT NULL DEFAULT 1, -- if needed for non-LKR
  subtotal_amount NUMERIC(12,2) NOT NULL CHECK (subtotal_amount >= 0),
  tax_amount      NUMERIC(12,2) NOT NULL DEFAULT 0 CHECK (tax_amount >= 0),
  discount_amount NUMERIC(12,2) NOT NULL DEFAULT 0 CHECK (discount_amount >= 0),
  total_amount    NUMERIC(12,2) GENERATED ALWAYS AS
                   ((subtotal_amount + tax_amount) - discount_amount) STORED,
  paid_amount     NUMERIC(12,2) NOT NULL DEFAULT 0 CHECK (paid_amount >= 0),
  outstanding_amount NUMERIC(12,2) GENERATED ALWAYS AS (total_amount - paid_amount) STORED,
  description     TEXT,
  status_id       INT NOT NULL REFERENCES invoice_statuses(status_id) ON DELETE RESTRICT,
  created_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
  CONSTRAINT ck_due_after_invoice CHECK (due_date >= invoice_date),
  CONSTRAINT ck_paid_not_exceed_total CHECK (paid_amount <= total_amount)
);

CREATE INDEX idx_invoices_customer ON invoices(customer_id);
CREATE INDEX idx_invoices_status ON invoices(status_id);
CREATE INDEX idx_invoices_dates ON invoices(due_date, invoice_date);

-- === Banks & payments ===
CREATE TABLE banks (
  bank_id         INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  bank_name       VARCHAR(255) NOT NULL,
  bank_short_name VARCHAR(50)  NOT NULL UNIQUE,
  bank_code       VARCHAR(8)   NOT NULL UNIQUE
);

CREATE TABLE cheque_payments (
  cheque_id      INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  cheque_number  VARCHAR(100) NOT NULL,
  branch_details VARCHAR(255),
  amount         NUMERIC(12,2) NOT NULL CHECK (amount > 0),
  cheque_date    DATE NOT NULL,
  banking_date   DATE, -- when actually deposited; can be null until deposited
  description    TEXT,
  bank_id        INT NOT NULL REFERENCES banks(bank_id) ON DELETE RESTRICT,
  status_id      INT NOT NULL REFERENCES cheque_statuses(status_id) ON DELETE RESTRICT,
  created_at     TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_cheque_bank ON cheque_payments(bank_id);
CREATE INDEX idx_cheque_status ON cheque_payments(status_id);
CREATE INDEX idx_cheque_dates ON cheque_payments(cheque_date);

-- One cheque can cover many invoices; one invoice can be covered by many cheques
CREATE TABLE cheque_invoice_links (
  link_id   INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  cheque_id INT NOT NULL REFERENCES cheque_payments(cheque_id) ON DELETE CASCADE,
  invoice_id INT NOT NULL REFERENCES invoices(invoice_id) ON DELETE CASCADE,
  applied_amount NUMERIC(12,2) NOT NULL CHECK (applied_amount > 0),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  CONSTRAINT uq_cheque_invoice UNIQUE (cheque_id, invoice_id)
);

CREATE INDEX idx_chq_inv_invoice ON cheque_invoice_links(invoice_id);

CREATE TABLE cash_payments (
  cash_id     INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  amount      NUMERIC(12,2) NOT NULL CHECK (amount > 0),
  payment_date DATE NOT NULL,
  received_by VARCHAR(255),
  description TEXT,
  created_at  TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Remove invoice_id from cash_payments; allocate via link table (M:N)
CREATE TABLE cash_invoice_links (
  link_id    INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  cash_id    INT NOT NULL REFERENCES cash_payments(cash_id) ON DELETE CASCADE,
  invoice_id INT NOT NULL REFERENCES invoices(invoice_id) ON DELETE CASCADE,
  applied_amount NUMERIC(12,2) NOT NULL CHECK (applied_amount > 0),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  CONSTRAINT uq_cash_invoice UNIQUE (cash_id, invoice_id)
);

CREATE INDEX idx_cash_inv_invoice ON cash_invoice_links(invoice_id);

-- === Returns (structured) ===
CREATE TABLE returns (
  return_id      INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  invoice_id     INT NOT NULL REFERENCES invoices(invoice_id) ON DELETE CASCADE,
  return_date    DATE NOT NULL,
  returned_items JSONB NOT NULL, -- [{ "item_id": "...", "qty": 1, "amount": 100.00 }]
  return_reason  TEXT,
  adjusted_amount NUMERIC(12,2) NOT NULL CHECK (adjusted_amount >= 0),
  created_at     TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Optional: add a CHECK using a trigger to validate adjusted_amount equals JSON sum.

-- === RBAC ===
CREATE TABLE roles (
  role_id   INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  role_name VARCHAR(50) UNIQUE NOT NULL
);

CREATE TABLE permissions (
  permission_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  permission_name VARCHAR(50) UNIQUE NOT NULL,
  permission_description TEXT
);

CREATE TABLE role_permissions (
  role_permission_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  role_id INT NOT NULL REFERENCES roles(role_id) ON DELETE CASCADE,
  permission_id INT NOT NULL REFERENCES permissions(permission_id) ON DELETE CASCADE,
  CONSTRAINT uq_role_perm UNIQUE (role_id, permission_id)
);

CREATE TABLE users (
  user_id      INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  username     VARCHAR(100) UNIQUE NOT NULL,
  password_hash VARCHAR(255) NOT NULL,
  email        VARCHAR(255) UNIQUE,
  full_name    VARCHAR(255),
  role_id      INT REFERENCES roles(role_id) ON DELETE SET NULL,
  is_active    BOOLEAN NOT NULL DEFAULT TRUE,
  created_at   TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at   TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- === Settings & Audit ===
CREATE TABLE settings (
  setting_key   VARCHAR(100) PRIMARY KEY,
  setting_value TEXT NOT NULL,
  description   TEXT,
  created_at    TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at    TIMESTAMPTZ NOT NULL DEFAULT now(),
  created_by    INT REFERENCES users(user_id) ON DELETE SET NULL,
  updated_by    INT REFERENCES users(user_id) ON DELETE SET NULL
);

CREATE TABLE activity_history (
  history_id       INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id          INT REFERENCES users(user_id) ON DELETE SET NULL,
  action_type      VARCHAR(100) NOT NULL,
  details          TEXT,
  action_timestamp TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- === Helpful indexes ===
CREATE INDEX idx_settings_updated_at ON settings(updated_at);
CREATE INDEX idx_activity_user_time ON activity_history(user_id, action_timestamp);

INSERT INTO customer_statuses (status_name) VALUES ('active'), ('inactive'), ('banned'), ('suspect');
INSERT INTO invoice_statuses (status_name) VALUES ('Open'), ('Paid'), ('Overdue');
INSERT INTO cheque_statuses (status_name) VALUES ('Pending'), ('Cashed'), ('Bounced');
INSERT INTO roles (role_name) VALUES ('Administrator'), ('User'), ('Guest');

INSERT INTO permissions (permission_name, permission_description) VALUES
('create_user', 'Ability to create new users'),
('edit_user', 'Ability to edit existing users'),
('delete_user', 'Ability to delete users'),
('create_invoice', 'Ability to create new invoices'),
('edit_invoice', 'Ability to edit existing invoices'),
('delete_invoice', 'Ability to delete invoices');

-- Grant all perms to Administrators; subset to Users
INSERT INTO role_permissions (role_id, permission_id)
SELECT r.role_id, p.permission_id FROM roles r, permissions p WHERE r.role_name = 'Administrator';

INSERT INTO role_permissions (role_id, permission_id)
SELECT r.role_id, p.permission_id
FROM roles r, permissions p
WHERE r.role_name = 'User' AND p.permission_name IN ('create_invoice', 'edit_invoice');
